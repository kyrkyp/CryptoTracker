@page "/watchlist"

@using CryptoTracker.sdk
@using CryptoTracker.sdk.Models
@inject CryptoTrackerClient Crypto
@implements IAsyncDisposable

<PageTitle>Watchlist</PageTitle>

<div class="page-container container-fluid">
    <h2 class="page-title">Crypto Watchlist</h2>

    @if (_isLoading)
    {
        <p>Loading watchlist...</p>
    }
    else
    {
        <div class="card dashboard-card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h4 class="card-title mb-0">Market Overview</h4>
                    <small class="text-muted">
                        Auto-refresh every @RefreshSeconds seconds
                    </small>
                </div>
                @if (_lastUpdated.HasValue)
                {
                    <small class="last-updated">
                        @GetHumanizedUpdateTime()
                    </small>
                }
            </div>

            <div class="card-body">
                @if (!string.IsNullOrWhiteSpace(_inlineMessage))
                {
                    <div class="alert alert-success py-2 mb-3">
                        @_inlineMessage
                    </div>
                }

                @if (_entries.Count == 0)
                {
                    <p class="text-muted">No data available.</p>
                }
                else
                {
                    <div class="table-responsive">
                        <table class="table table-sm align-middle dashboard-table">
                            <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Name</th>
                                <th class="text-end">Price (USD)</th>
                                <th class="text-end">Trend</th>
                                <th class="text-end">24h %</th>
                                <th class="text-end">Last Updated</th>
                                <th class="text-end">Action</th>
                            </tr>
                            </thead>
                            <tbody>
                            @foreach (var e in _entries)
                            {
                                var positive = e.Quote.Change24HPercent >= 0;
                                var isEditing = string.Equals(_editingSymbol, e.Coin.Symbol, StringComparison.OrdinalIgnoreCase);

                                <tr>
                                    <td class="symbol-cell">
                                        <span class="symbol-badge symbol-badge-outline">
                                            @e.Coin.Symbol.ToUpperInvariant()
                                        </span>
                                    </td>
                                    <td>@e.Coin.Name</td>
                                    <td class="text-end">
                                        <span class="@GetPriceChangeClass(e)">
                                            @e.Quote.Price
                                        </span>
                                    </td>

                                    <td class="text-end sparkline-cell">
                                        <svg viewBox="0 0 100 24"
                                             preserveAspectRatio="none"
                                             class="sparkline @(positive ? "sparkline-up" : "sparkline-down")">
                                            <polyline fill="none"
                                                      points="@GetSparklinePoints(e)" />
                                        </svg>
                                    </td>

                                    <td class="text-end">
                                        <span class="change-pill @(positive ? "change-up" : "change-down")">
                                            @e.Quote.Change24HPercent.ToString("0.##")%
                                        </span>
                                    </td>

                                    <td class="text-end">
                                        @e.Quote.Timestamp.LocalDateTime.ToLongTimeString()
                                    </td>

                                    <td class="text-end">
                                        @if (isEditing)
                                        {
                                            <div class="add-inline">
                                                <input class="form-control form-control-sm add-inline-input"
                                                       type="number"
                                                       step="0.0001"
                                                       placeholder="Amount"
                                                       @bind="_editAmount" />

                                                <input class="form-control form-control-sm add-inline-input"
                                                       type="number"
                                                       step="0.01"
                                                       placeholder="Buy price"
                                                       @bind="_editBuyPrice" />

                                                <button class="btn btn-primary btn-xs"
                                                        @onclick="() => ConfirmAddToPortfolioAsync(e.Coin.Symbol)">
                                                    Add
                                                </button>
                                                <button class="btn btn-link btn-xs text-muted"
                                                        @onclick="CancelAddToPortfolio">
                                                    Cancel
                                                </button>
                                            </div>
                                        }
                                        else
                                        {
                                            <button class="btn btn-outline-primary btn-sm"
                                                    @onclick="() => StartAddToPortfolio(e)">
                                                Add to portfolio
                                            </button>
                                        }
                                    </td>
                                </tr>
                            }
                            </tbody>
                        </table>
                    </div>
                }
            </div>
        </div>
    }
</div>

@code {
    private const int RefreshSeconds = 10;

    private readonly List<WatchEntry> _entries = new();
    private bool _isLoading;
    private PeriodicTimer? _timer;
    private CancellationTokenSource? _cts;
    private DateTimeOffset? _lastUpdated;

    // inline add-to-portfolio state
    private string? _editingSymbol;
    private decimal _editAmount;
    private decimal _editBuyPrice;
    private string? _inlineMessage;
    
    private readonly Dictionary<string, decimal> _lastPrices =
        new(StringComparer.OrdinalIgnoreCase);

    private readonly Dictionary<string, PriceChangeDirection> _priceDirections =
        new(StringComparer.OrdinalIgnoreCase);
    
    private readonly Dictionary<string, List<decimal>> _priceHistory =
        new(StringComparer.OrdinalIgnoreCase);


    private enum PriceChangeDirection
    {
        None,
        Up,
        Down
    }


    protected override async Task OnInitializedAsync()
    {
        _cts = new CancellationTokenSource();
        await LoadOnceAsync(_cts.Token);

        _timer = new PeriodicTimer(TimeSpan.FromSeconds(RefreshSeconds));
        _ = RefreshLoopAsync(_cts.Token);
    }

    private async Task LoadOnceAsync(CancellationToken ct)
    {
        _isLoading = true;
        try
        {
            _entries.Clear();

            var coins = await Crypto.Market.GetTopCoinsAsync(10, ct);
            foreach (var coin in coins)
            {
                var quote = await Crypto.Market.GetPriceAsync(coin.Symbol, "usd", ct);

                // ---- price direction (αν το έχεις ήδη, κράτα το ίδιο) ----
                var direction = PriceChangeDirection.None;

                if (_lastPrices.TryGetValue(coin.Symbol, out var lastPrice))
                {
                    const decimal epsilon = 0.0000001m;

                    if (quote.Price > lastPrice + epsilon)
                        direction = PriceChangeDirection.Up;
                    else if (quote.Price < lastPrice - epsilon)
                        direction = PriceChangeDirection.Down;
                }

                _entries.Add(new WatchEntry(coin, quote));
                _priceDirections[coin.Symbol] = direction;
                _lastPrices[coin.Symbol] = quote.Price;

                // ---- price history για sparkline ----
                if (!_priceHistory.TryGetValue(coin.Symbol, out var history))
                {
                    history = new List<decimal>();
                    _priceHistory[coin.Symbol] = history;
                }

                history.Add(quote.Price);

                // κρατάμε μόνο τα τελευταία 20 σημεία ανά coin
                const int maxPoints = 20;
                if (history.Count > maxPoints)
                {
                    history.RemoveRange(0, history.Count - maxPoints);
                }
            }

            _lastUpdated = DateTimeOffset.UtcNow;
        }
        finally
        {
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string GetSparklinePoints(WatchEntry entry)
    {
        if (!_priceHistory.TryGetValue(entry.Coin.Symbol, out var history) ||
            history.Count < 2)
        {
            return string.Empty;
        }

        var values = history.ToArray();
        var min = values.Min();
        var max = values.Max();
        var range = max - min;

        // προστασία από division by zero → flat line
        if (range == 0)
            range = 1;

        var n = values.Length;
        var sb = new System.Text.StringBuilder();

        for (var i = 0; i < n; i++)
        {
            // x: 0 → 100
            var x = (double)i / (n - 1) * 100.0;

            // y: 0 → 24 (SVG height), inverted (0 = top)
            var normalized = (double)(values[i] - min) / (double)range;
            var y = 24.0 - normalized * 24.0;

            sb.Append(x.ToString("0.##", System.Globalization.CultureInfo.InvariantCulture));
            sb.Append(',');
            sb.Append(y.ToString("0.##", System.Globalization.CultureInfo.InvariantCulture));
            sb.Append(' ');
        }

        return sb.ToString().TrimEnd();
    }


    private async Task RefreshLoopAsync(CancellationToken ct)
    {
        if (_timer is null) return;

        try
        {
            while (await _timer.WaitForNextTickAsync(ct))
            {
                await LoadOnceAsync(ct);
            }
        }
        catch (OperationCanceledException)
        {
            // ignore
        }
    }
    
    private string GetPriceChangeClass(WatchEntry entry)
    {
        if (!_priceDirections.TryGetValue(entry.Coin.Symbol, out var dir) ||
            dir == PriceChangeDirection.None)
        {
            return "price-neutral";
        }

        return dir == PriceChangeDirection.Up
            ? "price-up-anim"
            : "price-down-anim";
    }


    // ---------- Add to portfolio logic ----------

    private void StartAddToPortfolio(WatchEntry entry)
    {
        _editingSymbol = entry.Coin.Symbol;
        _editAmount = 0.01m;
        _editBuyPrice = entry.Quote.Price;
        _inlineMessage = null;
    }

    private void CancelAddToPortfolio()
    {
        _editingSymbol = null;
        _inlineMessage = null;
    }

    private async Task ConfirmAddToPortfolioAsync(string symbol)
    {
        if (_editAmount <= 0 || _editBuyPrice <= 0)
        {
            _inlineMessage = "Please enter valid amount and price.";
            return;
        }

        await Crypto.Portfolio.AddOrUpdateHoldingAsync(
            symbol.Trim(),
            _editAmount,
            _editBuyPrice);

        _inlineMessage = $"Added {symbol.ToUpperInvariant()} to your portfolio.";
        _editingSymbol = null;
    }

    // ---------- Last updated human-friendly text ----------

    private string GetHumanizedUpdateTime()
    {
        if (_lastUpdated is null)
            return "Never updated";

        var dt = _lastUpdated.Value.LocalDateTime;
        var diff = DateTime.Now - dt;

        if (diff.TotalSeconds < 10)
            return "Updated just now";

        if (diff.TotalSeconds < 60)
            return $"Updated {diff.Seconds} seconds ago";

        if (diff.TotalMinutes < 60)
            return $"Updated {diff.Minutes} minutes ago";

        if (diff.TotalHours < 24)
            return $"Updated at {dt:HH:mm}";

        return $"Updated on {dt:dd MMM yyyy, HH:mm}";
    }

    public ValueTask DisposeAsync()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _timer?.Dispose();

        return ValueTask.CompletedTask;
    }

    private record WatchEntry(CoinInfo Coin, PriceQuote Quote);
}
